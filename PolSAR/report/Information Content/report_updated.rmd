---
title: "Information Content in Color Images"
author: "Professor Alejando & Ulile"
date: "13/01/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introdução

As imagens coloridas contêm certas propriedades no espaço de cores CEILab. Tais imagens chamadas de "ideal" quando aplicadas técnicas extatisticas pode-se obter uma natureza de informações conhecidas por "maximum realizable color information" (MRCI).

Basicamente MRCI possui os dados distribuidos uniformemente no espaço CIELab. "A "não conformidade" com MRCI é uma medida de distância entre distribuições de imagens observada e a imagem MRCI".

A hipótese principal do presente trabalho consiste em avaliar qualidade da imagem ideal. Graças a diferentes métricas, pode-se medir distância entre distribuições dos dados duma imagem ideal e uma simulada. Uma das métricas mais utilizadas é a divergência de Kullback-Leibler e, consequentemente será utilizada.

Os autores obtêm uma versão empírica da imagem MRCI com os pontos amostrais distribuidos uniformemente no espaço CIELab $[L^*, a^*, b^*]$ limitado no intervalo $[0,100]\times [−200,200]\times [−200,200]$; os pontos válidos são mapeados no espaço $[R, G, B]$ no intervalo $[0, 1]^3$. Somente pontos válidos no espaço RGB são considerados.

## Etapas  
   
O trabalho divide-se em seguintes etapas:   
`* Selecão e preparação de imagens ideais;`     
`* Carregar imagens no ambiente;`   
`* Exploração dos dados;`   
`* Escolha de tamanho de bins;`   
`* Escolha de histograma;`   
`* ...`   
`* Aplicação de Kullback-Leibler;`   
``* ...``   

## Ensaios

Para o teste, escolheu-se três imagens, com duas referências que já foram usadas pelos autores. Tais imagens foram carregadas para o ambiente usandos a funcão $loadImage(...)$ do pacote [colordistance]([https://cran.r-project.org/web/packages/colordistance/vignettes/color-spaces.html]).

#### Carregamento
```{r echo=FALSE, message=FALSE, warning=FALSE}
require(colordistance)
require(plot3D)
require(imager)
require(HistogramTools)

# read the ideal "pauli"
img_ <- load.image("../../image/original/mandrill.png")

lpoints <- img_[,,,1]

## convertendo original para lab
lab_img_ <- RGBtoLab(img_)

#cria grade no intervalo especificados!
dataMESH <- mesh(seq(from=0, to=1, length.out=50),
                 seq(from=0, to=1, length.out=50),
                 seq(from=0, to=1, length.out=50))

rgb_ideal <- data.frame(cbind(dataMESH$x, dataMESH$y, dataMESH$z))

#converte para espaco Lab usando a referência da luz D65.
lab_ref <- convertColorSpace(rgb_ideal, from = "CIE RGB", 
                             to = "Lab", from.ref.white = NULL,
                             to.ref.white = "D65", sample.size = NULL)

```
O histograma em baixo nos mostra como os dados do componente L "Luminância" estão agrupados em cada uma das imagens.

**Faça novamente a figura abaixo, mostrando lado a lado a imagem e o histograma da sua componente L**

**Conclua esta seção exploratória mostrando a imagem "ideal" e o histograma da sua banda de luminância**

```{r echo=FALSE, warning=FALSE}
#getting the histogram of L component in each image
par(mfrow = c(1, 2))
plot(img_)
title("Visualizacão da Lena")
hist(lpoints, breaks = "FD", xlab = "L",
                                 ylab = "Frequência",
     main = "Histograma do componente L")

## imagem de referência e a sua histograma. 
## mudei a função anteriormente usa "image", pois achei 
## imappend mais relevante e controi a imagem ideal de 
## de forma mais natural.

iR <- as.cimg(rgb_ideal$X1)
iG <- as.cimg(rgb_ideal$X2)
iB <- as.cimg(rgb_ideal$X3)

iL <- as.cimg(lab_ref$L)
ia <- as.cimg(lab_ref$a)
ib <- as.cimg(lab_ref$b)


par(mfrow = c(1, 3))
imappend(list(iR, iG, iB), "C") %>% plot
title("Ideal em espço RGB")

imappend(list(iL, ia, ib), "C") %>% plot
title("Ideal em espço Lab")

hist(lab_ref$L, breaks = "FD", xlab = "L",
                               ylab = "Frequência",
     main = "Histograma de componente L")


```

# Aplicação

A seguir veremos a aplicação da técnica proposta.

Sejam $O=(r_O, g_O, b_O)$ a imagem original (de Lena, neste exemplo) em formato RGB, e $T(O)=(L_O, a_O, b_O)$ a sua versão transformada para o formato CIELab. 
A transformação $T$ é 1-a-1, isto é, ela é inversível e temos $T^{-1}$.
Temos ainda a imagem ideal $I=(L_I,a_I,b_I)$ já em formato CieLab.
Nosso objetivo é modificar a imagem original de tal forma que o histograma da sua componente $L_O$ seja o mais próximo possível ao histograma dessa mesma componente na imagem ideal $L_I$, digamos $h_{L_I}$.
Utilizaremos a função empírica de $L_O$, denotada $\widehat{F}_{L_O}$ e a inversa da função empírica de $L_I$, denotada $\widehat{F}_{L_I}^{-1}$.

Faremos essa modificação em duas etapas:

   1. deixar o histograma de $L_O$ uniforme (equalizado); isso será feito aplicando aos dados $L_O$ a sua função empírica: $\widehat{F}_{L_O}(L_O)$.
   2. aplicar $\widehat{F}_{L_I}^{-1}(\widehat{F}_{L_O}(L_O))$.

Assim, a versão melhorada da imagem original em formato CIELab tem as componentes
$$
\big(\widehat{F}_{L_I}^{-1}(\widehat{F}_{L_O}(L_O)), a_O, b_O\big),
$$
e a visualizaremos em formato RGB: $T^{-1}\big(\widehat{F}_{L_I}^{-1}(\widehat{F}_{L_O}(L_O)), a_O, b_O\big)$.

## Operações
```{r echo=FALSE}
   equalize <- function(imagem) {
     imagemeq <- ecdf(imagem)(imagem)
     dim(imagemeq) <- dim(imagem)
     return(imagemeq)
   }

   ## equalização do componente L de original
   img_eq <- equalize(lab_img_[,,,1])

   ## aplicando a inversão ao componente L
   hist_mix <- HistToEcdf(hist(lab_ref$L, breaks = "FD", plot = F),
                     inverse = T)(equalize(img_eq))
   
   ## criar nova image lena com componente L uniformizada e ajustada
   ## à ter histograma aproximada igual ao componente L de ideal.
   img_out <- array(c(hist_mix, img_[,,,2], img_[,,,3]), dim = c(512, 512, 1, 3))
   
   ## criando objeto cmig a fim de poder ser manipulador pelo pacote imager.
   img_final <- as.cimg(img_out)
   
   par(mfrow = c(1, 3))
   plot(img_final)
   title("Visualizacão da imagem lena final")
   hist(hist_mix, main = "Histograma mixada em inversão", "FD")
   hist(img_eq, main = "Histograma equalizada", "FD")
```